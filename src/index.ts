import * as Path from 'path';
import {detokenizeAsync, ValuesArrayAsync} from 'detokenizer';
import {platformPaths, isPlatformPathIdentifier} from 'platform-paths';
import {unusedFilename, separatorIncrementer, Incrementer, isSamePath, escapeHtml, regexpReplace} from './utils';

/**
 * Types.
 */

export interface SaveAsPathOptions {
	destination: string;
	deleteOriginal: boolean;
	overwriteDestination: boolean;
	incrementer: 'space' | 'dash' | 'underscore' | 'parentheses';
	tokenStart?: string;
	tokenEnd?: string;
	tokenChars?: string;
	tokenReplacer?: (name: string) => string | number | null | undefined | Promise<string | number | null | undefined>;
}

export interface Options {
	[x: string]: unknown; // To silence TS
	saving: {
		destination: string;
		deleteOriginal: boolean;
		overwriteDestination: boolean;
		incrementer: 'space' | 'dash' | 'underscore' | 'parentheses';
	};
}

export interface MakeOptionSchemaOptions {
	extraTokens?: Record<string, string>;
	tokenStart?: string;
	tokenEnd?: string;
}

/**
 * Drovp option schema maker.
 */
export function makeOptionSchema({
	extraTokens = {},
	tokenStart = '<',
	tokenEnd = '>',
}: MakeOptionSchemaOptions = {}): any {
	tokenStart = escapeHtml(tokenStart);
	tokenEnd = escapeHtml(tokenEnd);

	return {
		name: 'saving',
		type: 'namespace',
		schema: [
			{
				name: 'destination',
				type: 'path',
				kind: 'directory',
				default: '<basename>',
				title: `Destination`,
				description: `
				<p>Where to save the file. Relative path starts at the input file's directory.</p>
				<p><b>Available tokens:</b></p>
				<p>
					Platform folders: <code>${tokenStart}tmp${tokenEnd}</code>, <code>${tokenStart}home${tokenEnd}</code>, <code>${tokenStart}downloads${tokenEnd}</code>, <code>${tokenStart}documents${tokenEnd}</code>, <code>${tokenStart}pictures${tokenEnd}</code>, <code>${tokenStart}music${tokenEnd}</code>, <code>${tokenStart}videos${tokenEnd}</code>, <code>${tokenStart}desktop${tokenEnd}</code><br>
					<code>${tokenStart}basename${tokenEnd}</code> - <b>result</b> file basename <code>/foo/bar.jpg</code> → <code>bar.jpg</code><br>
					<code>${tokenStart}filename${tokenEnd}</code> - file name without the extension <code>/foo/bar.jpg</code> → <code>bar</code><br>
					<code>${tokenStart}extname${tokenEnd}</code> - <b>result</b> file extension with the dot <code>/foo/bar.jpg</code> → <code>.jpg</code><br>
					<code>${tokenStart}ext${tokenEnd}</code> - <b>result</b> file extension without the dot <code>/foo/bar.jpg</code> → <code>jpg</code><br>
					<code>${tokenStart}dirname${tokenEnd}</code> - directory path <code>/foo/bar/baz.jpg</code> → <code>/foo/bar</code><br>
					<code>${tokenStart}dirbasename${tokenEnd}</code> - name of a parent directory <code>/foo/bar/baz.jpg</code> → <code>bar</code><br>
					<code>${tokenStart}srcBasename${tokenEnd}</code> - <b>original</b> file basename <code>/foo/bar.jpg</code> → <code>bar.jpg</code><br>
					<code>${tokenStart}srcExtname${tokenEnd}</code> - <b>original</b> file extension with the dot <code>/foo/bar.jpg</code> → <code>.jpg</code><br>
					<code>${tokenStart}srcExt${tokenEnd}</code> - <b>original</b> file extension without the dot <code>/foo/bar.jpg</code> → <code>jpg</code><br>
					${Object.entries(extraTokens)
						.map(([name, description]) => `<code>${tokenStart}${name}${tokenEnd}</code> - ${description}`)
						.join('<br>')}
				</p>`,
			},
			{
				name: 'deleteOriginal',
				type: 'boolean',
				default: true,
				title: `Delete original`,
				description: `Ensures the original file is deleted.`,
			},
			{
				name: 'overwriteDestination',
				type: 'boolean',
				default: true,
				title: `Overwrite destination`,
				description: (value: boolean, {saving}: Options) =>
					saving.deleteOriginal
						? `Overwrite destination, even if it's a different file than original.`
						: `Overwrite destination, but only if it's a different file than original.`,
			},
			{
				name: 'incrementer',
				type: 'select',
				options: {
					space: 'Space: file 1',
					dash: 'Dash: file-1',
					underscore: 'Underscore: file_1',
					parentheses: 'Parentheses: file (1)',
				},
				default: 'space',
				title: `Increment style`,
				description: `What filename incrementation style to use when destination shouldn't be overwritten.`,
				isHidden: (_: string, {saving}: Options) => saving.deleteOriginal && saving.overwriteDestination,
			},
		],
	};
}

const incrementers: Record<string, Incrementer | undefined> = {
	space: separatorIncrementer(' '),
	dash: separatorIncrementer('-'),
	underscore: separatorIncrementer('_'),
	parentheses: undefined,
};

/**
 * Save as path.
 *
 * Accepts options generated by options schema above.
 */
export async function saveAsPath(
	originalPath: string,
	extension: string,
	{
		deleteOriginal = false,
		overwriteDestination = false,
		incrementer: incrementerName = 'space',
		destination = '<basename>',
		tokenStart = '<',
		tokenEnd = '>',
		tokenChars = '[a-zA-Z0-9]+',
		tokenReplacer,
	}: SaveAsPathOptions
) {
	const dirname = Path.dirname(originalPath);
	const srcExtname = Path.extname(originalPath);
	const srcBasename = Path.basename(originalPath);
	const filename = Path.basename(srcBasename, srcExtname);
	const extname = `.${extension}`;
	const basename = `${filename}${extname}`;
	const incrementer = incrementers[incrementerName];
	const pathParts: Record<string, string> = {
		srcExtname,
		srcExt: srcExtname[0] === '.' ? srcExtname.slice(1) : srcExtname,
		srcBasename,
		filename,
		dirname,
		ext: extension,
		extname,
		basename,
		dirbasename: Path.basename(dirname),
	};

	const replacers: ValuesArrayAsync = [
		[
			new RegExp(`${regexpReplace(tokenStart)}(?<name>${tokenChars})${regexpReplace(tokenEnd)}`),
			async (_, match) => {
				const name = match.groups?.name as string;
				console.log(name, pathParts[name]);
				if (pathParts.hasOwnProperty(name)) return pathParts[name] || '';
				if (isPlatformPathIdentifier(name)) return await platformPaths[name]({maxAge: Infinity});
				if (tokenReplacer) {
					const value = await tokenReplacer(name);
					if (value != null) return value;
				}
				throw new Error(`Unknown token "${match[0]}".`);
			},
		],
		[regexpReplace(tokenStart), tokenStart],
	];

	if (tokenEnd) replacers.push([regexpReplace(tokenEnd), tokenEnd]);

	let destinationPath = await detokenizeAsync(destination, replacers);

	destinationPath = Path.resolve(dirname, destinationPath);

	const samePath = isSamePath(destinationPath, originalPath);

	if (deleteOriginal) {
		if (!overwriteDestination && !samePath) {
			destinationPath = await unusedFilename(destinationPath, {incrementer});
		}
	} else if (samePath || !overwriteDestination) {
		const singleTry = samePath && overwriteDestination;

		destinationPath = await unusedFilename(destinationPath, {
			incrementer,
			maxTries: singleTry ? 1 : undefined,
			throwOnMaxTries: !singleTry,
		});
	}

	return destinationPath;
}
